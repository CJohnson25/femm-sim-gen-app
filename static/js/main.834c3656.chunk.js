(this["webpackJsonpfemm-sim-gen-app"]=this["webpackJsonpfemm-sim-gen-app"]||[]).push([[0],{115:function(n,e,t){},116:function(n,e,t){},125:function(n,e,t){"use strict";t.r(e);var i=t(0),a=t.n(i),c=t(40),l=t.n(c),r=(t(115),t(116),t(193)),o=t(182),s=t(186),_=t(183),d=t(178),h=t(12),u=t(90),j=t.n(u),b=t(175),x=t(1);function O(n){var e=n.children,t=a.a.useState(!1),i=Object(h.a)(t,2),c=i[0],l=i[1];return Object(x.jsx)(b.a,{open:c,title:"Copied to clipboard!",leaveDelay:1500,onClose:function(){l(!1)},children:e({copy:function(n){j()(n),l(!0)}})})}function g(n){var e=n.outputText;return Object(x.jsxs)(o.a,{container:!0,spacing:2,justifyContent:"center",children:[Object(x.jsxs)(o.a,{item:!0,xs:8,children:[Object(x.jsx)(s.a,{variant:"h2",children:"Output"}),Object(x.jsx)(s.a,{children:"Copy this LUA script and paste it in the LUA console in your FEMM program."})]}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(O,{children:function(n){var t=n.copy;return Object(x.jsx)(_.a,{variant:"contained",color:"primary",onClick:function(){return t(e)},children:"Click to Copy"})}})}),Object(x.jsx)(o.a,{item:!0,xs:8,children:Object(x.jsx)(d.a,{fullWidth:!0,multiline:!0,rows:20,value:e})})]})}var m=["millimeters","inches"],f=["N30","N33","N35","N38","N40","N42","N45","N48","N50","N52","N55"],A=["1006 Steel","1010 Steel","1018 Steel","1020 Steel","1117 Steel"],p=["10 AWG","12 AWG","14 AWG","16 AWG","18 AWG","20 AWG","22 AWG","24 AWG","26 AWG","28 AWG","30 AWG","32 AWG","34 AWG","36 AWG"],T=t(39);function H(n){var e=n.name,t=n.control,i=n.label;return Object(x.jsx)(T.a,{name:e,control:t,render:function(n){var e=n.field,t=e.onChange,a=e.value;return Object(x.jsx)(d.a,{onChange:t,value:a,label:i})}})}var C=t(174),E=t(190),N=t(191);function R(n){var e=n.label,t=n.children,i=n.childrenShowFalse,c=void 0===i?null:i,l=a.a.useState(!1),r=Object(h.a)(l,2),s=r[0],_=r[1];return Object(x.jsxs)(o.a,{container:!0,spacing:2,children:[Object(x.jsxs)(o.a,{item:!0,xs:12,children:[Object(x.jsx)(C.a,{component:"legend",children:e}),Object(x.jsx)(E.a,{control:Object(x.jsx)(N.a,{value:s,onChange:function(){return _(!s)}}),label:s?"Yes":"No"})]}),Object(x.jsx)(o.a,{item:!0,xs:12,children:s?t:c})]})}var G=t(181),I=t(176);function y(n){var e=n.control,t=n.name,i=n.options,a=n.label;return Object(x.jsx)(T.a,{control:e,name:t,render:function(n){var e=n.field,t=e.onChange,c=e.value;return Object(x.jsxs)(x.Fragment,{children:[Object(x.jsx)(s.a,{children:a}),Object(x.jsx)(I.a,{onChange:t,value:c,sx:{minWidth:100},children:i.map((function(n){return Object(x.jsx)(G.a,{value:n,children:n},n)}))})]})}})}function v(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:2,alignItems:"flex-end",children:[Object(x.jsx)(o.a,{item:!0,xs:6,children:Object(x.jsx)(H,{control:e,name:"BACK_IRON_HEIGHT",label:"Back Iron Height"})}),Object(x.jsx)(o.a,{item:!0,xs:6,children:Object(x.jsx)(y,{label:"Iron Material",control:e,name:"BACK_IRON_MATERIAL",options:A})})]})}function M(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:2,children:[Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"HALBACH_LENGTH",label:"Length"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"HALBACH_WIDTH",label:"Width"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"HALBACH_HEIGHT",label:"Height"})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(y,{label:"Grade",control:e,name:"HALBACH_GRADE",options:f})})]})}function L(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:2,justifyContent:"center",children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(s.a,{children:"Magnets"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"MAGNET_LENGTH",label:"Length"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"MAGNET_WIDTH",label:"Width"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"MAGNET_HEIGHT",label:"Height"})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(y,{label:"Grade",control:e,name:"MAGNET_GRADE",options:f})})]})}function D(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:4,children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(s.a,{variant:"h2",children:"Rotor"})}),Object(x.jsxs)(o.a,{item:!0,xs:12,container:!0,spacing:2,justifyContent:"center",children:[Object(x.jsx)(o.a,{item:!0,xs:6,sm:4,children:Object(x.jsx)(H,{control:e,name:"AIR_GAP",label:"Air Gap"})}),Object(x.jsx)(o.a,{item:!0,xs:6,sm:4,children:Object(x.jsx)(H,{control:e,name:"MAGNET_GAP",label:"Magnet Spacing"})}),Object(x.jsx)(o.a,{item:!0,xs:6,sm:4,children:Object(x.jsx)(H,{control:e,name:"NUM_ROTOR_POLE_PAIRS",label:"# of Pole Pairs"})})]}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(L,{control:e})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(R,{label:"Halbach?",children:Object(x.jsx)(M,{control:e})})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(R,{label:"Back Iron?",children:Object(x.jsx)(v,{control:e})})})]})}var S=t(180),w=t(185);function P(n){var e=n.control,t=n.name,i=n.options;return Object(x.jsx)(T.a,{name:t,control:e,render:function(n){var e=n.field,t=e.onChange,a=e.value;return Object(x.jsx)(w.a,{value:a,onChange:t,children:i.map((function(n){return Object(x.jsx)(E.a,{value:n,label:n,control:Object(x.jsx)(S.a,{})},n)}))})}})}var U=t(179);function B(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:4,children:[Object(x.jsxs)(o.a,{container:!0,spacing:1,item:!0,xs:12,children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(H,{control:e,name:"FILEPATH",label:"File Path"})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(U.a,{severity:"info",children:"Must have a trailing slash. If using windows this must begin with a drive letter and contain trailing backslashe. for example (C:\\path\\to\\save\\)"})})]}),Object(x.jsxs)(o.a,{container:!0,spacing:1,item:!0,xs:12,children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(H,{control:e,name:"FILENAME",label:"File Name"})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(U.a,{severity:"info",children:"This must end in '.fem'"})})]})]})}function W(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:4,justifyContent:"center",children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(s.a,{variant:"h2",children:"General"})}),Object(x.jsx)(o.a,{item:!0,children:Object(x.jsx)(P,{control:e,name:"UNITS",options:m})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(R,{label:"Auto run Analysis?",children:Object(x.jsx)(B,{control:e})})})]})}function k(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:2,children:[Object(x.jsx)(o.a,{item:!0,xs:6,children:Object(x.jsx)(H,{control:e,name:"CONDUCTOR_WIDTH",label:"Conductor Width"})}),Object(x.jsx)(o.a,{item:!0,xs:6,children:Object(x.jsx)(H,{control:e,name:"CONDUCTOR_HEIGHT",label:"Conductor Height"})})]})}function F(n){var e=n.control;return Object(x.jsx)(o.a,{container:!0,spacing:2,children:Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(H,{control:e,name:"CONDUCTOR_DIAMETER",label:"Conductor Diameter"})})})}function K(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:4,justifyContent:"center",children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(U.a,{severity:"info",children:"Currently this will only simulate 3 phase designs wiith overlapped windings."})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(R,{label:"Rectangle conductor?",childrenShowFalse:Object(x.jsx)(F,{control:e}),children:Object(x.jsx)(k,{control:e})})}),Object(x.jsxs)(o.a,{container:!0,spacing:2,item:!0,xs:12,children:[Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"NUM_PHASE_TURNS",label:"# of Turns per Phase"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"ROTOR_TO_STATOR_GAP",label:"Rotor to Stator Air Gap"})}),Object(x.jsx)(o.a,{item:!0,xs:4,children:Object(x.jsx)(H,{control:e,name:"PEAK_CURRENT",label:"Peak Current"})})]}),Object(x.jsx)(o.a,{item:!0,xs:6,children:Object(x.jsx)(y,{label:"Wire Gauge",control:e,name:"CONDUCTOR_MATERIAL",options:p})})]})}function Y(n){var e=n.control;return Object(x.jsxs)(o.a,{container:!0,spacing:4,children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(s.a,{variant:"h2",children:"Stator"})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(K,{control:e})})]})}function X(){var n=Object(T.b)({defaultValues:{UNITS:"millimeters",NUM_ROTOR_POLE_PAIRS:3,MAGNET_GAP:1,MAGNET_LENGTH:1,MAGNET_WIDTH:1,MAGNET_HEIGHT:1,MAGNET_GRADE:"N50",HALBACH:0,HALBACH_LENGTH:1,HALBACH_WIDTH:1,HALBACH_HEIGHT:1,HALBACH_GRADE:"N50",BACK_IRON:0,BACK_IRON_HEIGHT:1,BACK_IRON_MATERIAL:"1006 Steel",AIR_GAP:10,STATOR:1,RECTANGLE_CONDUCTOR:0,CONDUCTOR_WIDTH:1,CONDUCTOR_HEIGHT:1,CONDUCTOR_DIAMETER:2,CONDUCTOR_MATERIAL:"32 AWG",PEAK_CURRENT:10,ROTOR_TO_STATOR_GAP:1,NUM_PHASES:3,NUM_PHASE_TURNS:4,ANALYSIS:0,FILEPATH:"",FILENAME:""}}),e=n.control,t=(0,n.watch)(),i=t?function(n){return JSON.stringify(n,null,2).replace(/^{\n?|\n?}$/g,"").replace(/"(.*)": /g,"$1 = ").replace(/,\n/g,"\n")+'\n\n\nfunction init () \n  -- Create Doc\n  newdocument(0)\n  -- Init Problem\n  mi_probdef(0, UNITS, "planar", 1e-008, MAGNET_LENGTH)\n  -- Init Grid\n  mi_showgrid()\n  mi_setgrid(0.001, "cart")\n\n  init_materials()\n  init_circuits() \n  build_objects()\n\n  mi_zoomnatural()\n  \n  if ANALYSIS == 1 then \n    analyze()\n  end\n\nend\n\nfunction init_materials()\n  mi_getmaterial("Air")\n  mi_getmaterial(BACK_IRON_MATERIAL)\n  mi_getmaterial(MAGNET_GRADE)\n  if HALBACH == 1 then\n    mi_getmaterial(HALBACH_GRADE)\n  end\n\n  if STATOR == 1 then\n    mi_getmaterial(CONDUCTOR_MATERIAL)\n  end\nend\n\nfunction init_circuits() \n  for i = 1, NUM_PHASES do\n    local phase_label = get_phase_label(i)\n    local current = get_phase_current(i)\n    local circuit_type = 1 -- 1 for series 0 for parallel\n    mi_addcircprop(phase_label, current, circuit_type)\n  end\nend\n\nfunction get_full_filepath()\n  return FILEPATH .. FILENAME\nend\n\nfunction get_v_gap () \n  return get_total_height() * 2\nend\n\nfunction get_h_gap ()\n  return get_total_width() * 1\nend\n\nfunction get_bound_height()\n  return get_v_gap() * 3\nend\n\nfunction get_bound_width() \n  return get_h_gap() * 3\nend\n\nfunction get_pole_width ()\n  local pole_width = MAGNET_WIDTH + MAGNET_GAP\n  if HALBACH == 1 then\n    return pole_width + HALBACH_WIDTH + MAGNET_GAP\n  end\n\n  return pole_width\nend\n\nfunction is_halbach_taller() \n  if HALBACH == 1 then\n    if MAGNET_HEIGHT < HALBACH_HEIGHT then\n      return 1\n    end\n  end\n\n  return 0\nend\n\nfunction get_tallest_magnet_height() \n  if is_halbach_taller() == 1 then\n    return HALBACH_HEIGHT\n  end\n\n  return MAGNET_HEIGHT\nend\n\nfunction get_magnet_height_diff() \n  if HALBACH == 1 then\n    return abs(MAGNET_HEIGHT - HALBACH_HEIGHT)\n  end\n\n  return 0\nend\n\nfunction get_total_width ()\n  local width = (get_nonhalbach_count() - 1) * (MAGNET_WIDTH + MAGNET_GAP)\n\n  if HALBACH == 1 then\n    return width + get_halbach_count() * (HALBACH_WIDTH + MAGNET_GAP)\n  end\n\n  return width\nend\n\nfunction get_total_height ()\n  local total_height = get_tallest_magnet_height() * 2 + AIR_GAP\n  if BACK_IRON == 1 then\n    return total_height + BACK_IRON_HEIGHT * 2\n  end\n\n  return total_height\nend\n\nfunction get_halbach_count() \n  return NUM_ROTOR_POLE_PAIRS * 2\nend\n\nfunction get_nonhalbach_count() \n  return NUM_ROTOR_POLE_PAIRS * 2 + 1 \nend\n\nfunction get_total_magnet_count ()\n  local count = get_nonhalbach_count()\n\n  if HALBACH == 1 then\n    return count + get_halbach_count()\n  end\n\n  return count\nend\n\nfunction get_phase_offset(phase)\n  return mod(phase, NUM_PHASES)\nend\n\nfunction get_phase_current(phase)\n  local angle = 360 / NUM_PHASES\n  return PEAK_CURRENT * sin(rad((phase - 1) * angle))\nend\n\nfunction get_phase_label(phase) \n  return "Phase " .. tostring(phase)\nend\n\n-- TODO make this use a look up table for diameters based on gague selected\n-- function get_coil_diameter()\n--   return CONDUCTOR_DIAMETER\n-- end\n\nfunction get_coil_gap()\n  return get_pole_width() / NUM_PHASES\nend\n\nfunction get_coil_offset(coil_num, phase)\n  local phase_offset = get_phase_offset(phase)\n  local total_offset = (coil_num * NUM_PHASES - phase_offset) * get_coil_gap() + get_pole_width() / 2\n  if RECTANGLE_CONDUCTOR == 1 then\n  total_offset = total_offset - CONDUCTOR_WIDTH / 2\n  end\n  return total_offset\nend\n\nfunction get_stator_pole_pairs()\n  return NUM_ROTOR_POLE_PAIRS - 1\nend\n\nfunction get_total_coils() \n  return NUM_PHASES * get_stator_pole_pairs()\nend\n\nfunction get_total_phase_legs() \n  return get_stator_pole_pairs() * 2\nend\n\nfunction get_total_legs() \n  return get_total_coils() * 2\nend\n\n\n\n\nfunction build_objects ()\n  build_air_bounds()\n  -- Build the sides separately\n  build_rotor(0)\n  build_rotor(1)\n  \n  if STATOR == 1 then\n    build_coil_phases()\n  end\n\n  build_analysis_nodes()\nend\n\nfunction build_air_bounds()\n  build_square_block(0, 0, get_bound_width() , get_bound_height(), "Air", "", 0, 0, 0, "corner")\nend\n\nfunction build_rotor(side) \n  build_rotor_magnets(side)\n  if BACK_IRON == 1 then\n    local x = get_h_gap()\n    local y = get_v_gap() - BACK_IRON_HEIGHT\n    if side == 1 then \n      y = get_v_gap() + AIR_GAP + get_tallest_magnet_height() * 2\n    end\n    build_rotor_iron(x, y)\n  end\nend\n\nfunction build_rotor_magnets (side)\n  local count = get_total_magnet_count()\n  \n  local modulus = 2\n  if HALBACH == 1 then \n    modulus = 4\n  end\n  \n  -- init horizontal offset at h gap\n  local current_x_offset = get_h_gap()\n  -- init horizontal offset at v gap. Add gap for the other side\n  local y_offset = get_v_gap()\n\n  local offset = 90\n  if HALBACH == 1 then\n    offset = 0\n  end\n\n  for i = 0, count - 1 do\n    local direction = (360/modulus) * (mod(i, modulus) + 1) + offset\n    if side == 1 then\n      direction =  (360/modulus) * (modulus - mod(i, modulus) + 1) + offset\n    end\n\n    local is_halbach = 0\n    local is_end = 0\n    local width = MAGNET_WIDTH\n    local current_y_offset = y_offset\n    if side == 1 then\n      current_y_offset = current_y_offset + AIR_GAP + get_tallest_magnet_height()\n    end\n    local height_diff = get_magnet_height_diff()\n\n    -- If iterating Halbach and If current iteration is halbach magnet\n    if HALBACH == 1 and mod(i, 2) == 1 then\n      is_halbach = 1\n      width = HALBACH_WIDTH\n      if side == 1 then\n        if is_halbach_taller() == 0 then\n          current_y_offset = current_y_offset + height_diff\n        end\n      end\n    else\n      if side == 1 then\n        if is_halbach_taller() == 1 then\n          current_y_offset = current_y_offset + height_diff\n        end\n      end\n    end\n\n    -- First or last iteration are half magnets\n    if i == 0 or i == (count - 1) then\n      is_end = 1\n      width = width / 2\n    end\n\n    build_magnet(current_x_offset, current_y_offset, direction, is_halbach, is_end)\n    current_x_offset = current_x_offset + width + MAGNET_GAP\n  end\nend\n\nfunction build_magnet (x, y, direction, is_halbach, is_end)\n  local w = MAGNET_WIDTH\n  local h = MAGNET_HEIGHT\n  local grade = MAGNET_GRADE\n\n  if is_halbach == 1 then\n    w = HALBACH_WIDTH\n    h = HALBACH_HEIGHT\n    grade = HALBACH_GRADE\n  end \n\n  if is_end == 1 then\n    w = w / 2\n  end\n\n  build_square_block(x, y, w, h, grade, "", direction, 0, 0, "center")\nend\n\nfunction build_rotor_iron (x, y)\n  build_square_block(x, y, get_total_width(), BACK_IRON_HEIGHT, BACK_IRON_MATERIAL, "", 0, 0, 0, "center")\nend\n\nfunction build_coil_phases()\n  local starting_side = 0\n  for i = 0, NUM_PHASES - 1 do\n    build_coil_phase(i, starting_side)\n    starting_side = starting_side + 1\n  end\nend\n\nfunction build_coil_phase(phase, starting_side)\n  for i = 0, get_total_phase_legs() - 1 do\n    build_coil_leg(i, phase, starting_side)\n    starting_side = starting_side + 1\n  end\nend\n\nfunction build_coil_leg(coil_num, phase, starting_side) \n  -- local x = get_coil_offset(coil_num, phase) + get_h_gap()\n  local x = get_coil_offset(coil_num, phase) + get_h_gap() + get_coil_gap() * 3\n  local y = get_v_gap() + get_tallest_magnet_height() + AIR_GAP - ROTOR_TO_STATOR_GAP - CONDUCTOR_DIAMETER\n  if RECTANGLE_CONDUCTOR == 1 then\n    y = get_v_gap() + get_tallest_magnet_height() + AIR_GAP - ROTOR_TO_STATOR_GAP - CONDUCTOR_HEIGHT\n  end\n  local turns = NUM_PHASE_TURNS\n  if mod(starting_side, 2) == 1 then\n    y = get_v_gap() + get_tallest_magnet_height() + ROTOR_TO_STATOR_GAP\n    turns = turns * -1\n  end\n  \n  local circuit = get_phase_label(phase + 1)\n  if RECTANGLE_CONDUCTOR == 1 then\n    local w = CONDUCTOR_WIDTH\n    local h = CONDUCTOR_HEIGHT\n    build_square_block(x, y, CONDUCTOR_WIDTH, CONDUCTOR_HEIGHT, CONDUCTOR_MATERIAL, circuit, 0, 0, turns, "center")\n  else \n    local h = CONDUCTOR_DIAMETER\n    build_circle_block(x, y, h, CONDUCTOR_MATERIAL, circuit, 0, 0, turns)\n  end\nend\n\nfunction build_analysis_nodes () \n  local x = get_h_gap()\n  local x1 = x + get_total_width()\n  local y = get_v_gap() + AIR_GAP / 2 + MAGNET_HEIGHT\n  \n  mi_addnode(x, y)\n  mi_addnode(x1, y)\nend\n\n\n\n\n\nfunction build_circle_block(x, y, h, material, circuit, direction, group, turns)\n  local y1 = y + h\n\n  mi_addnode(x, y)\n  mi_addnode(x, y1)\n\n  mi_addarc(x, y, x, y1, 180, 1)\n  mi_addarc(x, y1, x, y, 180, 1)\n\n  local labelX = x\n  local labelY = y + h/2\n\n  add_block_props(labelX, labelY, material, circuit, direction, group, turns)\nend\n\nfunction build_square_block(x, y, w, h, material, circuit, direction, group, turns, label_position)\n  local x1 = x + w\n  local y1 = y + h\n\n  mi_addnode(x, y)\n  mi_addnode(x1, y)\n  mi_addnode(x, y1)\n  mi_addnode(x1, y1)\n\n  mi_addsegment(x, y, x1, y)\n  mi_addsegment(x1, y, x1, y1)\n  mi_addsegment(x, y1, x1, y1)\n  mi_addsegment(x, y1, x, y)\n\n  local labelX = x + w/2\n  local labelY = y + h/2\n  if (label_position == "corner") then\n    labelX = x + w/8\n    labelY = y + h/8\n  end\n\n  add_block_props(labelX, labelY, material, circuit, direction, group, turns)\nend\n\nfunction add_block_props(labelX, labelY, material, circuit, direction, group, turns)\n  mi_addblocklabel(labelX, labelY)\n  mi_selectlabel(labelX, labelY)\n  mi_setblockprop(material, 1, 0, circuit, direction, group, turns)\n  mi_clearselected()\nend\n\n\n\nfunction analyze()\n  mi_saveas(get_full_filepath())\n  mi_analyze()\n  mi_loadsolution()\n  mo_showdensityplot(1, 0, 1, 0, "bmag")\nend\n\ninit()\n'}(t):"";return Object(x.jsxs)(o.a,{container:!0,spacing:5,children:[Object(x.jsxs)(o.a,{item:!0,xs:12,container:!0,spacing:2,justifyContent:"center",children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(s.a,{variant:"h2",children:"Motor Sim Generator"})}),Object(x.jsxs)(o.a,{item:!0,xs:8,children:[Object(x.jsx)(s.a,{children:"This form will generate a LUA script that can then be run in FEMM to produce a 2D simulation of a 3 phase air-cored toroidially wound axial flux permanant magnet motor."}),Object(x.jsx)(s.a,{children:"This is still a work in progress and will hopefully support other motor architechtures in the future."})]})]}),Object(x.jsx)(o.a,{item:!0,xs:12,lg:4,children:Object(x.jsx)(W,{control:e})}),Object(x.jsx)(o.a,{item:!0,xs:12,lg:4,children:Object(x.jsx)(D,{control:e})}),Object(x.jsx)(o.a,{item:!0,xs:12,lg:4,children:Object(x.jsx)(Y,{control:e})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(g,{outputText:i})})]})}var z=t(94),J=t.n(z),q=t(95),Q=t.n(q),V=t(93),$=t(192);function Z(){return Object(x.jsxs)(o.a,{container:!0,style:{marginTop:20},justifyContent:"space-between",children:[Object(x.jsx)(o.a,{item:!0,children:Object(x.jsxs)(s.a,{children:["Version: ",V.version]})}),Object(x.jsxs)(o.a,{item:!0,children:[Object(x.jsx)($.a,{target:"_blank",variant:"contained",color:"primary",href:"https://www.youtube.com/channel/UCQk0CkSexTb7GQvpGxj4kxw",children:Object(x.jsx)(J.a,{})}),Object(x.jsx)($.a,{target:"_blank",variant:"contained",color:"primary",href:"https://github.com/CJohnson25/femm-sim-gen-app/",children:Object(x.jsx)(Q.a,{})})]})]})}var nn=function(){return Object(x.jsx)("div",{className:"App",children:Object(x.jsx)(r.a,{maxWidth:"xl",children:Object(x.jsxs)(o.a,{container:!0,spacing:5,children:[Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(X,{})}),Object(x.jsx)(o.a,{item:!0,xs:12,children:Object(x.jsx)(Z,{})})]})})})},en=function(n){n&&n instanceof Function&&t.e(3).then(t.bind(null,194)).then((function(e){var t=e.getCLS,i=e.getFID,a=e.getFCP,c=e.getLCP,l=e.getTTFB;t(n),i(n),a(n),c(n),l(n)}))};l.a.render(Object(x.jsxs)(a.a.StrictMode,{children:[Object(x.jsx)("link",{rel:"stylesheet",href:"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"}),Object(x.jsx)("link",{rel:"stylesheet",href:"https://fonts.googleapis.com/icon?family=Material+Icons"}),Object(x.jsx)(nn,{})]}),document.getElementById("root")),en()},93:function(n){n.exports=JSON.parse('{"name":"femm-sim-gen-app","homepage":"http://CJohnson25.github.io/femm-sim-gen-app","version":"0.11.1","private":true,"dependencies":{"@emotion/react":"^11.7.1","@emotion/styled":"^11.6.0","@mui/icons-material":"^5.4.1","@mui/material":"^5.4.1","@testing-library/jest-dom":"^5.12.0","@testing-library/react":"^11.2.6","@testing-library/user-event":"^12.8.3","clipboard-copy":"^4.0.1","react":"^17.0.2","react-dom":"^17.0.2","react-hook-form":"^7.27.0","react-scripts":"4.0.3","web-vitals":"^1.1.1"},"scripts":{"predeploy":"npm run build","deploy":"gh-pages -d build","start":"npm i && react-scripts start","build":"react-scripts build","test":"react-scripts test","eject":"react-scripts eject"},"eslintConfig":{"extends":["react-app","react-app/jest"]},"browserslist":{"production":[">0.2%","not dead","not op_mini all"],"development":["last 1 chrome version","last 1 firefox version","last 1 safari version"]},"devDependencies":{"gh-pages":"^3.1.0"}}')}},[[125,1,2]]]);
//# sourceMappingURL=main.834c3656.chunk.js.map